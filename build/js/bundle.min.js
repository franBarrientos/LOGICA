const unidades=document.querySelector(".unidades");function mostrarFormulario(e){const n=document.createElement("DIV");switch(n.classList.add("modal"),e){case"unidad1":n.innerHTML='\n        <div class="teoria">\n            <h1>LOGICA DE PREPOSICIONES 1</h1>\n            <p>1.3. INTERPRETACION\n            Dada una fórmula proposicional compuesta, la interpretación define\n            qué fórmulas atómicas del lenguaje de proposiciones son falsas (0) y\n            qué fórmulas son verdaderas (1).\n            Definición:\n            Sea Var el conjunto de átomos del lenguaje L\n            Una interpretación es una función de Var  {0,1},\n            (asigna a cada elemento de Var un 0 o un 1)\n            28\n            Var = {p1\n            , p2\n            , p3\n            , p4\n            , … }\n            Ejemplo:\n            Sea Var = { p, q, r } ; una interpretación I1\n            , puede estar dada\n            por: I1 = { p }\n            Significa que la imagen de p es 1, mientras los restantes átomos\n            (elementos) de Var tienen como imagen 0\n            Si I2 = { q, r } significa que la imagen de q es 1 y la de r es 1\n            también, mientras la de p es 0\n            Si I3 = { p, q, r } significa que la imagen de p, q y r es 1\n            29\n            Definición:\n            - Sea I una interpretación.\n            - Sea Form el conjunto de fórmulas de L\n            Una valuación bajo una interpretación I, es cualquier función\n            vI de Form en {0,1}, que satisface las siguientes reglas:\n            v.1) vI\n            (pn\n            ) = I(pn\n            ) para cada variable proposicional.\n            Cuando la fórmula es una variable proposicional, su\n            valuación coincide con la asignación que le hace su\n            interpretación.\n            30\n            v.2) Si ϕ y ρ son fbf arbitrarias, se define θ según la siguiente\n            tabla:\n            Ejemplo:\n            Sea Var = { p, q, r } y J una interpretación dada por: J = { q }.\n            La valuación de la fórmula:\n            Porque: vJ\n            (p) = 0\n            31\n            y la interpretación I = { p }\n            porque: vI\n            (p) = 1 y vI\n            (q) = 0\n            32\n            Sea\n            para la interpretación I = { p, q, r }\n            porque: vI\n            (p) = 1, vI\n            (q) = 1 y vI\n            (r) = 1\n            Valuaciones de θ1\n            y θ2 para diferentes interpretaciones de\n            Var = {ϕ, ρ} (valuaciones de ϕ y ρ). Reconozca cada una de\n            las interpretaciones para las diferentes valuaciones de θ\n            33\n            Ejercicios:\n            Sea Var = { p, q }. Encuentre la valuación de la fórmula θ para\n            las interpretaciones dadas en cada caso\n            34\n            1.4 FORMULAS SATISFACIBLES\n            Sea θ una fórmula y sea I una interpretación.\n            θ es verdadera bajo I, si su valor de verdad (valuación) es 1\n            se dice que I satisface a θ;\n            o que θ es satisfacible por I\n            Si θ es falsa bajo I, cuando su valor de verdad es 0\n            se dice que I no satisface a θ\n            Definición:\n            35\n            Ejercicio:\n            Diga en qué caso\n            a)\n            b)\n            c)\n            d)\n            36\n            1.5 MODELOS – TAUTOLOGIAS - CONTRADICCIONES\n            Sea θ una fórmula y sea I una interpretación.\n            I es un modelo para θ si I satisface a θ;\n            se dice también que θ tiene como modelo a I\n            Definición\n            Definición\n            θ es tautología si todas las interpretaciones son modelos para θ\n            Las tautologías se denotan con T0\n            Si una fórmula θ es tautológica, se escribe:\n            37\n            38\n            Los tipos mas importantes de Tautología son:\n            Las equivalencias lógicas\n            Las implicaciones lógicas\n            Se utilizan como esquemas de sustitución en procesos de\n            razonamiento\n            Se utilizan como esquemas de razonamientos válidos\n            Definición\n            θ es contradicción, insatisfacible o inconsistente si es falsa para\n            todas las interpretaciones.\n            Las contradicciones se denotan con F0\n            Una contradicción no tiene interpretaciones que sean modelos.\n            Una fórmula lógica que no es tautología ni contradicción se\n            denomina contingencia\n            Una contingencia es satisfacible pero no es tautología;\n            significa que para alguna(s) interpretación(es) tiene valor de\n            verdad 1, pero no para otras.\n            39\n            contingencia tautología contradicción tautología\n            Fórmulas\n            Insatisfacibles\n            Fórmulas\n            Satisfacibles\n            Tautologías\n            40\n            Sea S un conjunto de fórmulas de manera que\n            y una valuación.\n            La valuación es modelo para S\n            si es modelo para todas las fórmulas de S </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      ';break;case"unidad2":n.innerHTML='\n        <div class="teoria">\n            <h1>Relaciones de Recurrencia</h1>\n            <p>SUCESIONES\n            Definición 1. Una sucesión es una función que va de\n            Naturales en Reales; si va de Naturales en Enteros se\n            llama Sucesión entera\n            S: a1\n            , a2\n            , a3\n            ,…, an o S: {an\n            : n∈N } o S: {an\n            }\n            Los elementos a1\n            , a2\n            , a3\n            , … son términos de la sucesión.\n            a1 es el primer término de la sucesión, a2 es el segundo\n            término de la sucesión y así siguiendo an es el término nésimo de la sucesión.\n            2019 4\n            Si se incluye el cero en el dominio de la sucesión,\n            a0\n            será el primer elemento de la sucesión y\n            an\n            será el término (n+1)-ésimo de la sucesión.\n            Por ejemplo: en la sucesión 2, 4, 6, … la fórmula para\n            determinar el n-ésimo término es relativamente simple.\n            bn = 2n\n            2019 5\n            Si necesitamos calcular b7\n            se resolverá 2∙7 = 14\n            Es claro que para conocer b7 no ha sido necesario\n            conocer los términos anteriores\n            Consideremos las siguientes sucesiones:\n            S1\n            :1, 2, 3, 4, 5, 6, …\n            S2\n            : 1, 4, 9, 16, 25, 36, …\n            S3\n            :1, 3, 5, 7, 9, 11,…\n            2019 6\n            Sin embargo no en todas las sucesiones es posible\n            conocer una fórmula explícita para el término n-ésimo,\n            por ejemplo\n            S4\n            : 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 . . .\n            Relaciones de Recurrencia\n            Hay series donde es posible conocer una expresión para el\n            término n-ésimo, pero este no es una función explícita de n.\n            2019 7\n            La sucesión de Fibonacci\n            S5\n            : 1, 1, 2, 3, 5, 8, 13, 21, . . .\n            cada término es la suma de los dos anteriores\n            a1=1, a2=1, an= an-1 + an-2 n ≥ 3\n            No tiene una fórmula explícita para an\n            ;\n            para conocer el valor de a7 es necesario conocer los\n            valores de a6\n            y de a5\n            ; para conocer el valor de a6 es\n            necesario conocer los valores de a5\n            y de a4\n            ; y así\n            siguiendo.\n            a7 = a6 + a5\n            a7 = a5 + a4 + a4 + a3 = a5 + 2a4 + a3\n            a7 = a4 + a3 + 2(a3 + a2\n            ) + a2 + a1 = a4 + 3a3 + 3a2 + a1\n            a7 = a3 + a2 + 3a3 + 3a2 + a1 = 4a3 + 4a2 + a1\n            a7 = 4a2 + a1 + 4a2 + a1 = 8a2 + 5a1\n            pero: a1 = a2 = 1\n            entonces: a7 = 8∙1 + 5∙1 = 13\n            Para calcular el término n-ésimo es necesario conocer\n            los términos anteriores.\n            2019 8\n            2019 9\n            Fórmula de Binet\n            (para calcular términos de Fibonacci)\n            (número áureo o número de oro)\n            Definición 2\n            Si en una sucesión S: a1\n            , a2\n            , a3\n            ,…,an\n            el término an puede ser expresado en función de los\n            términos anteriores an-1\n            , an-2\n            , an-3\n            ,…,a1\n            ;\n            la expresión es una relación de recurrencia y se puede\n            expresar:\n            an= F(an-1\n            , an-2\n            , an-3\n            ,…,a1\n            )\n            En general, para poder calcular los términos de una\n            sucesión, es necesario conocer al menos un término de\n            la misma. 2019 10\n            Definición 3\n            Sea k el entero menor para el cual tenemos asignados\n            valores de a1\n            ,a2\n            ,…,ak\n            an= F(an-1\n            , an-2\n            , an-3\n            ,…,a1\n            )\n            permite calcular valores únicos para an\n            si n>k.\n            2019 11\n            Los valores de a1\n            ,a2\n            ,…,ak\n            se llaman condiciones iniciales\n            o condiciones de frontera de la relación.\n            Las condiciones iniciales con la relación de recurrencia\n            generan unívocamente la sucesión. </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      ';break;case"unidad3":n.innerHTML='\n        <div class="teoria">\n            <h1>Estructuras Algebraicas Finitas</h1>\n            <p>Objetivo\n            Se analizarán las operaciones binarias y sus propiedades dentro de una estructura algebraica.\n            Definición de operación binaria\n            Operaciones como la suma, resta, multiplicación o división de números son consideradas\n            operaciones binarias, ya que asocian a un par de números con un resultado. En general, una\n            operación binaria tiene dos características esenciales:\n            • Se aplica a un par de elementos con una naturaleza determinada.\n            • Asocia a dicho par con otro único elemento de la misma naturaleza determinada; la\n            asociación se realiza por medio de un criterio definido.\n            En forma general, una operación binaria definida en un conjunto S no vacío es una función 𝑆 × 𝑆\n            que relaciona un par de elementos (𝑎, 𝑏) ∀ 𝑎, 𝑏 ∈ 𝑆 con una imagen 𝑐 ∈ 𝑆.\n            Ejemplo 7.1. Si se considera al conjunto de los números racionales y la suma, se tendrá que dicha\n            operación asocia a un par de números racionales otro único número racional; es decir, para el par\n            de números racionales �\n            𝑎\n            𝑏 ,\n            𝑐\n            𝑑\n            �, existe un único número denotado como 𝑎\n            𝑏 + 𝑐\n            𝑑 que se conoce como\n            la suma de 𝑎\n            𝑏 y 𝑐\n            𝑑\n            . El criterio para obtener la suma de dos números racionales es\n            𝑎\n            𝑏 +\n            𝑐\n            𝑑 = 𝑎𝑑 + 𝑏𝑐\n            𝑏𝑑\n            Además de las operaciones tradicionales, es posible expresar otras operaciones binarias.\n            Ejemplo 7.2. La tabla 7.1 especifica la operación binaria AND, que establece una operación lógica\n            utilizada en la electrónica y la computación\n            · 0 1\n            0 0 0\n            1 0 1\n            Tabla 7.1. Operación AND.\n            En este caso, el criterio que se establece para realizar la operación es la misma tabla, y el conjunto\n            sobre el cual se aplica es {0, 1}; en este caso se tendría:\n            0 · 1 = 0 1 · 0 = 0\n            1 · 1 = 1 0 · 0 = 0\n            Álgebra 2012\n            127 Elaboró: Ing. Aldo Jiménez Arteaga\n            Que son los resultados que la operación puede asignar.\n            Las operaciones binarias también pueden definirse por medio de reglas de correspondencia, y\n            haciendo uso de las operaciones binarias tradicionales.\n            Ejemplo 7.3. Sea la siguiente operación binaria\n            𝑥 ‡ 𝑦 = 𝑥𝑦 ∀ 𝑥, 𝑦 ∈ ℤ\n            Se puede obtener un resultado para la pareja (−1, 6):\n            −1 ‡ 6 = (−1)6\n            Cuyo resultado es 1.\n            Propiedades de las operaciones binarias\n            Cuando un conjunto tiene definida una operación binaria se puede formar un sistema algebraico\n            que posee una estructura definida, la cual está ligada a las diferentes propiedades que posea la\n            operación binaria.\n            Los niveles y diferentes tipos de estructuras algebraicas están sujetos a la naturaleza de las\n            propiedades que se cumplen para una operación en un conjunto dado. Así, las estructuras de\n            grupo, anillo y campo se diferencian por el número de operaciones y las propiedades que éstas\n            cumplen en un conjunto numérico dado.\n            La primera de estas propiedades es inherente al concepto de operación binaria: a cada par de\n            elementos de cierta naturaleza se le asigna un resultado de ésa misma naturaleza.\n            Ejemplo 7.4. Si se aplica la suma a los números naturales, el resultado será otro número natural:\n            𝑚 + 𝑛 = 𝑝 ∀ 𝑚, 𝑛, 𝑝 ∈ ℕ\n            Si se tuviesen los números naturales 3 y 4, el resultado de su suma es 7, otro número natural.\n            Esto quiere decir que una operación binaria es cerrada; o sea, una operación definida en un\n            conjunto S da como resultado un elemento de ese conjunto S.\n            Cerradura\n            Si el resultado de aplicar una operación binaria (∗) está definido en un conjunto S, entonces se\n            dice que S es cerrado con respecto a dicha operación binaria; es decir,\n            𝑎 ∗ 𝑏 ∈ 𝑆, ∀ 𝑎, 𝑏 ∈ 𝑆\n            Ejemplo 7.5. Sea la operación binaria 𝑥 ‡ 𝑦 = 𝑥𝑦 ∀ 𝑥, 𝑦 ∈ ℤ. Se obtiene un resultado que puede o\n            no pertenecer a los números enteros. Si el operando y fuese mayor a cero, el resultado es un\n            número entero; por ejemplo, (−2,3) arrojaría el siguiente resultado:\n            −2 ‡ 3 = (−2)−3\n            Álgebra 2012\n            128 Elaboró: Ing. Aldo Jiménez Arteaga\n            Que es −8 ∈ ℤ. En cambio si la pareja a operar fuese (3, −2), el resultado sería\n            3 ‡ −2 = (−3)−2\n            Que es el número fraccionario 1\n            9 ∉ ℤ, ya que es un número racional; por lo tanto, la operación (‡)\n            no es cerrada para el conjunto de los números enteros.\n            Ejemplo 7.6. Sea el conjunto 𝑋 = {𝑎̈, 𝑜̈, 𝑢̈} y la operación definida por la tabla 7.2.\n            ß ä ö ü\n            ä ä ö ü\n            ö ö ö ä\n            ü ä ö ü\n            Tabla 7.2. Operación Eszett definida para X.\n            Al aplicar la operación a una pareja de elementos, se puede observar que la operación es cerrada,\n            ya que siempre se obtendrá como resultado un elemento del conjunto X.\n            𝑎̈ß 𝑜̈= 𝑜̈ 𝑢̈ß 𝑢̈= 𝑢̈ 𝑜̈ß 𝑢̈= 𝑎̈\n            Asociatividad\n            Al momento de definir una operación binaria se precisó que sólo podía realizarse con dos\n            elementos de un solo conjunto; es decir, al tratar de operar tres elementos, primero se debe\n            realizar la operación con dos de ellos, y después trabajar con el resultado y el tercer elemento.\n            Este proceso de asociar elementos para operarlos se define como propiedad asociativa.\n            Para una operación binaria (∗) definida en el conjunto S, la asociación de elementos especifica\n            que:\n            (𝑎 ∗ 𝑏) ∗ 𝑐 = 𝑎 ∗ (𝑏 ∗ 𝑐)\n            Ejemplo 7.7. En la suma de números enteros se tiene la asociación cumplida.\n            (𝑎 + 𝑏) + 𝑐 = 𝑎 + (𝑏 + 𝑐) ∀ 𝑎, 𝑏, 𝑐 ∈ ℤ\n            Que a su vez es extensión de la suma en los números naturales.\n            Ejemplo 7.8. Para el conjunto X y la operación de la tabla 7.2, la asociación no puede cumplirse ya\n            que\n            𝑜̈ß (𝑜̈ß 𝑢̈) = 𝑜̈ß 𝑎̈⇒ 𝑜̈\n            (𝑜̈ß 𝑜̈) ß 𝑢̈= 𝑜̈ß 𝑢̈⇒ 𝑎̈\n            Que son dos resultados completamente diferentes.\n            Álgebra 2012\n            129 Elaboró: Ing. Aldo Jiménez Arteaga\n            Ejemplo 7.9. Para las matrices de orden 𝑚 × 𝑛 y la operación de suma, es posible asociar los\n            elementos que se operarán:\n            (𝐴𝑚×𝑛 + 𝐵𝑚×𝑛) + 𝐶𝑚×𝑛 = 𝐴𝑚×𝑛 + (𝐵𝑚×𝑛 + 𝐶𝑚×𝑛)\n            Y el resultado no se verá alterado.\n            Existencia del elemento neutro\n            Si existe un elemento e dentro de un conjunto, que tiene la propiedad de no alterar a otro\n            elemento a cuando se les aplica una operación binaria, entonces se habla de un elemento neutro.\n            Si se define la operación binaria (∗) dentro del conjunto S, y existe un elemento 𝑒 ∈ 𝑆 tal que\n            • 𝑎 ∗ 𝑒 = 𝑎, ∀ 𝑎 ∈ 𝑆, entonces e es un elemento neutro por la derecha.\n            • 𝑒 ∗ 𝑎 = 𝑎, ∀ 𝑎 ∈ 𝑆, entonces e es un elemento neutro por la izquierda.\n            • 𝑎 ∗ 𝑒 = 𝑒 ∗ 𝑎 ⇒ 𝑎, ∀ 𝑎 ∈ 𝑆, entonces e es un elemento neutro para (∗).\n            Esto quiere decir que un conjunto dado tendrá, al menos, un elemento neutro si éste es neutro\n            por la izquierda y por la derecha.\n            Ejemplo 7.10. Si se considera al conjunto de las matrices de orden 𝑚 × 𝑛 y la operación de\n            multiplicación, se verifica que el elemento neutro sería la matriz identidad:\n            𝐼𝑚𝐴𝑚×𝑛 = 𝐴𝑚×𝑛\n            Donde 𝐼𝑚 es la matriz identidad de orden m, la cual es un elemento neutro por la izquierda.\n            𝐼𝑛𝐴𝑛×𝑚 = 𝐴𝑛×𝑚\n            Donde 𝐼𝑛 es la matriz identidad de orden n, la cual es un elemento neutro por la derecha.\n            Estas son las propiedades que cumple la matriz identidad y que se estudiaron en el tema de\n            matrices y determinantes.\n            Ejemplo 7.11. El elemento neutro para la operación de suma en los números complejos sería el\n            número 0 + 0𝑖, ya que\n            (𝑥 + 𝑦𝑖) + (0 + 0𝑖) = 𝑥 + 𝑦𝑖 ∀ 𝑥 + 𝑦𝑖 ∈ ℂ\n            Por medio de la conmutación en ℂ, se verifica que 0 + 0𝑖 es neutro por la izquierda y por la\n            derecha.\n            Ejemplo 7.12. En el conjunto X del ejemplo 7.6 y la operación de la tabla 7.2, se puede verificar que\n            existen dos elementos neutros por la izquierda: ä y ü.\n            𝑎̈ß 𝑎̈= 𝑎̈ 𝑎̈ß 𝑜̈= 𝑜̈ 𝑎̈ß 𝑢̈= 𝑢̈\n            𝑢̈ß 𝑎̈= 𝑎̈ 𝑢̈ß 𝑜̈= 𝑜̈ 𝑢̈ß 𝑢̈= 𝑢̈\n            Álgebra 2012\n            130 Elaboró: Ing. Aldo Jiménez Arteaga\n            En cambio, estos elementos no son neutros por la derecha.\n            𝑎̈ß 𝑎̈= 𝑎̈ 𝑜̈ß 𝑎̈= 𝑜̈ 𝑢̈ß 𝑎̈= 𝑎̈\n            𝑎̈ß 𝑢̈= 𝑢̈ 𝑜̈ß 𝑢̈= 𝑎̈ 𝑢̈ß 𝑢̈= 𝑢̈\n            Y por lo tanto, la operación ß no posee elementos neutros.\n            Existencia de elementos inversos\n            Los elementos inversos se relacionan directamente con el elemento neutro. En este caso, si el\n            resultado de la operación binaria es el elemento neutro, entonces los dos elementos que\n            intervinieron en la operación son inversos uno del otro.\n            Al definir la operación binaria (∗) dentro del conjunto S, y tomando en cuenta la existencia del\n            elemento neutro 𝑒 ∈ 𝑆, se dice que\n            • 𝑎 ∗ 𝑎� = 𝑒, ∀ 𝑎 ∈ 𝑆, entonces 𝑎� es el elemento inverso de a por la derecha.\n            • 𝑎� ∗ 𝑎 = 𝑒, ∀ 𝑎 ∈ 𝑆, entonces 𝑎� es el elemento inverso de a por la izquierda.\n            • 𝑎 ∗ 𝑎� = 𝑎� ∗ 𝑎 ⇒ 𝑒, ∀ 𝑎 ∈ 𝑆, entonces 𝑎� es el elemento inverso de a para (∗).\n            Por lo tanto, si el inverso por la izquierda y por la derecha es el mismo, entonces es un elemento\n            inverso único para a. Además, un conjunto tendrá para cada elemento su correspondiente inverso\n            en una operación binaria.\n            Ejemplo 7.13. En la multiplicación de matrices de orden n, y que son no-singulares, se tiene que\n            𝐼𝑛𝐴𝑛 = 𝐴𝑛𝐼𝑛 ⇒ 𝐴𝑛\n            Donde 𝐼𝑛 define al elemento neutro. En consecuencia, el elemento inverso de A por la izquierda\n            será el mismo que el inverso por la derecha:\n            Ejemplo 7.14. Cada elemento del conjunto de los números reales tiene un solo inverso definido\n            para la operación de multiplicación:\n            𝑥 · 𝑥−1 ∀ 𝑥 ≠ 0 ∈ ℝ\n            Sabiendo que 1 es el elemento neutro en ℝ para la multiplicación, y que el cero es el único\n            elemento que no posee inverso.\n            Conmutatividad\n            Cuando una operación binaria permite que el orden de los elementos no influya en el resultado\n            que se obtendrá, se dice que la operación permite la conmutación. </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      ';break;case"unidad4":n.innerHTML='\n        <div class="teoria">\n            <h1>ALGEBRA DE BOOL</h1>\n            <p>Algebra de Boole\n            Operadores Lógicos:\n            Así como los operadores matemáticos (+, -, x,/, etc.) los operadores\n            lógicos son los que interrelacionan a las variables lógicas de entrada\n            entre sí.\n            Estos son:\n            AND cuyo símbolo es “●” ó “\n            ∧” ó “&”\n            OR cuyo símbolo es “+” ó “\n            ∨” ó “#”\n            NOT cuyo símbolo es “¯” ó “/” ó “!”\n            EJEMPLOS:\n            A ● B = A\n            ∧ B = A & B = A B (sólo hay una separación entre variables)\n            C + D = C\n            ∨ D = C # D\n            A = /A = !A\n            Con combinaciones entre estos 3 operadores se pueden implementar\n            cualquier función lógica posible.\n            Algebra de Boole\nOperadores Lógicos:\nAsí como los operadores matemáticos (+, -, x,/, etc.) los operadores\nlógicos son los que interrelacionan a las variables lógicas de entrada\nentre sí.\nEstos son:\nAND cuyo símbolo es “●” ó “\n∧” ó “&”\nOR cuyo símbolo es “+” ó “\n∨” ó “#”\nNOT cuyo símbolo es “¯” ó “/” ó “!”\nEJEMPLOS:\nA ● B = A\n∧ B = A & B = A B (sólo hay una separación entre variables)\nC + D = C\n∨ D = C # D\nA = /A = !A\nCon combinaciones entre estos 3 operadores se pueden implementar\ncualquier función lógica posible. </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      ';break;case"unidad5":n.innerHTML='\n        <div class="teoria">\n            <h1>GRAFOS</h1>\n            <p>Algebra de Boole\n            Operadores Lógicos:\n            Así como los operadores matemáticos (+, -, x,/, etc.) los operadores\n            lógicos son los que interrelacionan a las variables lógicas de entrada\n            entre sí.\n            Estos son:\n            AND cuyo símbolo es “●” ó “\n            ∧” ó “&”\n            OR cuyo símbolo es “+” ó “\n            ∨” ó “#”\n            NOT cuyo símbolo es “¯” ó “/” ó “!”\n            EJEMPLOS:\n            A ● B = A\n            ∧ B = A & B = A B (sólo hay una separación entre variables)\n            C + D = C\n            ∨ D = C # D\n            A = /A = !A\n            Con combinaciones entre estos 3 operadores se pueden implementar\n            cualquier función lógica posible. </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      ';break;case"unidad6":n.innerHTML='\n        <div class="teoria">\n            <h1>ARBOLES</h1>\n            <p>Un grafo conectado que contiene circuitos no simples se llama árbol. En el año de 1857 Arthur Cayley, matemático inglés, los empleó para contabilizar componente químicos, no obstante, es importante señalar que no solo es una herramienta de la química sino que se han utilizado en diversas áreas, por ejemplo, conforme el propio interés de la materia encaminado hacia las ciencias de la computación, se utiliza para la construcción de las redes.\n            6.1.1. Propiedades de los árboles\n            Entre las propiedades más importantes de los árboles está la presencia de un paseo entre cualquiera de dos vértices del árbol; segundo, que el número de vértices no es menor al número de aristas del árbol y que un árbol con más de dos vértices tiene por lo menos dos hojas.\n            \n             \n            \n            Un ejemplo claro de los árboles en la vida cotidiana son los árboles genealógicos. Para este caso, los vértices representan a los miembros de la familia y los arcos representan la relación de parentesco. Conforme los conocimientos adquiridos con anterioridad, el árbol no deja de ser un grafo, pero es del tipo no dirigido.\n            \n             \n            \n            Ejemplo de árbol genealógico:\n            \n            En este ejemplo cabe señalar que los recuadros representan los vértices del grafo y los arcos son las líneas que representan las relaciones de parentesco conforme a esta familia: </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      ';break;case"unidad7":n.innerHTML='\n        <div class="teoria">\n            <h1>LENGUAJES FORMALES Y AUTOMATAS</h1>\n            <p>La teoría de autómatas es una rama de la teoría de la computación que estudia las máquinas abstractas y los problemas que éstas son capaces de resolver. La teoría de autómatas está estrechamente relacionada con la teoría del lenguaje formal ya que los autómatas son clasificados a menudo por la clase de lenguajes formales que son capaces de reconocer. También son de gran utilidad en la teoría de la complejidad computacional.\n\n            Un autómata es un modelo matemático para una máquina de estado finito (FSM sus siglas en inglés). Una FSM es una máquina que, dada una entrada de símbolos, "salta" a través de una serie de estados de acuerdo a una función de transición (que puede ser expresada como una tabla). En la variedad común "Mealy" de FSMs, esta función de transición dice al autómata a qué estado cambiar dados unos determinados estado y símbolo.\n            \n            La entrada es leída símbolo por símbolo, hasta que es "consumida" completamente (piense en ésta como una cinta con una palabra escrita en ella, que es leída por una cabeza lectora del autómata; la cabeza se mueve a lo largo de la cinta, leyendo un símbolo a la vez) una vez la entrada se ha agotado, el autómata se detiene.\n            \n            Dependiendo del estado en el que el autómata finaliza se dice que este ha aceptado o rechazado la entrada. Si este termina en el estado "acepta", el autómata acepta la palabra. Si lo hace en el estado "rechaza", el autómata rechazó la palabra, el conjunto de todas las palabras aceptadas por el autómata constituyen el lenguaje aceptado por el mismo. </p>\n        \n            <button type="button" class="cerrar-modal">Cerrar</button>\n            </div>\n      '}setTimeout(()=>{document.querySelector(".teoria").classList.add("animar")},0),n.addEventListener("click",(function(e){if(e.preventDefault(),e.target.classList.contains("cerrar-modal")){document.querySelector(".teoria").classList.add("cerrar"),setTimeout(()=>{n.remove()},300)}})),e&&document.querySelector(".contenido-main").appendChild(n)}
/*! modernizr 3.6.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-webp-setclasses !*/unidades.addEventListener("click",(function(e){mostrarFormulario(e.target.id)})),function(e,n,a){function o(e,n){return typeof e===n}function s(e){var n=u.className,a=c._config.classPrefix||"";if(p&&(n=n.baseVal),c._config.enableJSClass){var o=new RegExp("(^|\\s)"+a+"no-js(\\s|$)");n=n.replace(o,"$1"+a+"js$2")}c._config.enableClasses&&(n+=" "+a+e.join(" "+a),p?u.className.baseVal=n:u.className=n)}function r(e,n){if("object"==typeof e)for(var a in e)d(e,a)&&r(a,e[a]);else{var o=(e=e.toLowerCase()).split("."),i=c[o[0]];if(2==o.length&&(i=i[o[1]]),void 0!==i)return c;n="function"==typeof n?n():n,1==o.length?c[o[0]]=n:(!c[o[0]]||c[o[0]]instanceof Boolean||(c[o[0]]=new Boolean(c[o[0]])),c[o[0]][o[1]]=n),s([(n&&0!=n?"":"no-")+o.join("-")]),c._trigger(e,n)}return c}var i=[],l=[],t={_version:"3.6.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,n){var a=this;setTimeout((function(){n(a[e])}),0)},addTest:function(e,n,a){l.push({name:e,fn:n,options:a})},addAsyncTest:function(e){l.push({name:null,fn:e})}},c=function(){};c.prototype=t,c=new c;var d,u=n.documentElement,p="svg"===u.nodeName.toLowerCase();!function(){var e={}.hasOwnProperty;d=o(e,"undefined")||o(e.call,"undefined")?function(e,n){return n in e&&o(e.constructor.prototype[n],"undefined")}:function(n,a){return e.call(n,a)}}(),t._l={},t.on=function(e,n){this._l[e]||(this._l[e]=[]),this._l[e].push(n),c.hasOwnProperty(e)&&setTimeout((function(){c._trigger(e,c[e])}),0)},t._trigger=function(e,n){if(this._l[e]){var a=this._l[e];setTimeout((function(){var e;for(e=0;e<a.length;e++)(0,a[e])(n)}),0),delete this._l[e]}},c._q.push((function(){t.addTest=r})),c.addAsyncTest((function(){function e(e,n,a){function o(n){var o=!(!n||"load"!==n.type)&&1==s.width;r(e,"webp"===e&&o?new Boolean(o):o),a&&a(n)}var s=new Image;s.onerror=o,s.onload=o,s.src=n}var n=[{uri:"data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=",name:"webp"},{uri:"data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==",name:"webp.alpha"},{uri:"data:image/webp;base64,UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA",name:"webp.animation"},{uri:"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",name:"webp.lossless"}],a=n.shift();e(a.name,a.uri,(function(a){if(a&&"load"===a.type)for(var o=0;o<n.length;o++)e(n[o].name,n[o].uri)}))})),function(){var e,n,a,s,r,t;for(var d in l)if(l.hasOwnProperty(d)){if(e=[],(n=l[d]).name&&(e.push(n.name.toLowerCase()),n.options&&n.options.aliases&&n.options.aliases.length))for(a=0;a<n.options.aliases.length;a++)e.push(n.options.aliases[a].toLowerCase());for(s=o(n.fn,"function")?n.fn():n.fn,r=0;r<e.length;r++)1===(t=e[r].split(".")).length?c[t[0]]=s:(!c[t[0]]||c[t[0]]instanceof Boolean||(c[t[0]]=new Boolean(c[t[0]])),c[t[0]][t[1]]=s),i.push((s?"":"no-")+t.join("-"))}}(),s(i),delete t.addTest,delete t.addAsyncTest;for(var m=0;m<c._q.length;m++)c._q[m]();e.Modernizr=c}(window,document);
//# sourceMappingURL=bundle.js.map
